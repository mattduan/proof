"""
A PROOF code generator utility script.
"""

import string
import re, sys
import datetime
import os
import getopt
import ConfigParser

# required path
#import PyStartup

from util.Trace import traceBack
import util.UniqueList as UniqueList

import proof.driver.MySQLConnection as MySQLConnection

# these names cannot be used as a variable name
RESTRICTED_VAR_NAMES = ['type']

CODE_TEMPLATE_HEADER = """\
""" + '"""' + """
%(description)s
""" + '"""'

OBJECT_DESCRIPTION = """\
%(file_header)s

This is a Data Object. It exists inside a PROOF and shouldn't be accessed
directly outside this PROOF implementation. Interfaces for outside applications
are made by the Aggregate Object. The Aggregate Object containing this Data
Object should have methods to access and modify this object.

NOTE: The code was originally generated by Proof Code Generator. You should
customize it as needed.
"""

OBJECT_FACTORY_DESCRIPTION = """\
%(file_header)s

This is the factory class for Customer object. It exists inside a PROOF and
shouldn't be accessed directly outside this PROOF implementation. Outside
applications should use AggregateFactory to create new aggregates.

NOTE: The code was originally generated by Proof Code Generator. You should
customize it as needed.
"""

AGGREGATE_DESCRIPTION = """\
%(file_header)s

NOTE: The code was originally generated by Proof Code Generator. Since an
aggregate is mostly a business decision in certain domains, this generator
doesn't provide intelligence to include the business decision. Though it is
possible to group tables and map relations to make it closer to what we need,
this will totally depend on the future growth with this framework. Currently,
every object is also considered as an aggregate. So, this code has to be
modified to fit your need. Maybe the file will be removed completely.
"""

AGGREGATE_FACTORY_DESCRIPTION = """\
%(file_header)s

NOTE: The code was originally generated by Proof Code Generator. This code
has to be modified to fit your need. Maybe the file will be removed completely.
Refer to %(table_name)sAggregate.py for details.
"""

REPOSITORY_DESCRIPTION = """\
%(file_header)s

NOTE: The code was originally generated by Proof Code Generator. This code
has to be modified to fit your need. Maybe the file will be removed completely.
Refer to %(table_name)sAggregate.py for details.
"""

OBJECT_TEMPLATE = """\
%(header)s

%(imports)s

#################### START OF CUSTOMIZED IMPORTS #####################
# Add additional imports in this block

##################### END OF CUSTOMIZED IMPORTS ######################


class %(table_name)s(BaseObject.BaseObject):

    ###################### START OF AUTO-GENERATED CODE #####################

    def __init__( self, aggregate, pk, logger=None ):
        """ + '"""' + """ Constructor.

            @param aggregate The aggregate object/instance which %(table_name)s object
                   belongs to.
            @param pk An ObjectKey object identifying the %(table_name)s object.
            @param logger A Logger object.
        """ + '"""' + """

        BaseObject.BaseObject.__init__( self,
                                        aggregate,
                                        pk,
                                        db_schema   = "%(schema_name)s",
                                        table_name  = "%(table_name)s",
                                        logger      = logger )

%(function_list)s

    ####################### END OF AUTO-GENERATED CODE ######################

    ######################## START OF CUSTOMIZED CODE #######################

    # add your customized methods in this block
    # def xxx(self):
    #     pass
        
    ######################### END OF CUSTOMIZED CODE ########################
"""

OBJECT_FACTORY_TEMPLATE = """\
%(header)s

%(imports)s

#################### START OF CUSTOMIZED IMPORTS #####################
# Add additional imports in this block

##################### END OF CUSTOMIZED IMPORTS ######################


class %(table_name)sFactory(ObjectFactory.ObjectFactory):

    ###################### START OF AUTO-GENERATED CODE #####################

    def __init__( self, aggregate, logger=None ):
        """ + '"""' + """ Constructor.

            @param aggregate The aggregate object/instance which %(table_name)s object
                   belongs to.
            @param logger A Logger object.
        """ + '"""' + """

        ObjectFactory.ObjectFactory.__init__( self,
                                              aggregate,
                                              schema_name = "%(schema_name)s",
                                              table_name  = "%(table_name)s",
                                              logger      = logger )

    ####################### END OF AUTO-GENERATED CODE ######################

    ######################## START OF CUSTOMIZED CODE #######################

    # add your customized methods in this block
    # def xxx(self):
    #     pass
        
    ######################### END OF CUSTOMIZED CODE ########################
"""

AGGREGATE_TEMPLATE = """\
%(header)s

%(imports)s

#################### START OF CUSTOMIZED IMPORTS #####################
# Add additional imports in this block

##################### END OF CUSTOMIZED IMPORTS ######################


class %(table_name)sAggregate(Aggregate.Aggregate):

    ###################### START OF AUTO-GENERATED CODE #####################

    def __init__( self,
                  proof_instance,
                  pk,
                  auto_commit       = True,
                  cascade_on_delete = False,
                  logger            = None ):
        """ + '"""' + """ Constructor.

            @param proof_instance A ProofInstance object/instance.
            @param pk An ObjectKey object identifying the %(table_name)sAggregate object.
            @param auto_commit A boolean value indicating whether commit will be performed
                   when DIRTY_AGE expires.
            @param cascade_on_delete A boolean value indicating whether deleting all
                   enclosed objects when deleting the aggregate.
            @param logger A Logger object.
        """ + '"""' + """

        Aggregate.Aggregate.__init__( self,
                                      proof_instance,
                                      pk,
                                      db_schema         = "%(schema_name)s",
                                      auto_commit       = auto_commit,
                                      cascade_on_delete = cascade_on_delete,
                                      logger            = logger )

%(function_list)s

    ####################### END OF AUTO-GENERATED CODE ######################

    ######################## START OF CUSTOMIZED CODE #######################

    # add your customized methods in this block
    # def xxx(self):
    #     pass
        
    ######################### END OF CUSTOMIZED CODE ########################
"""

AGGREGATE_FACTORY_TEMPLATE = """\
%(header)s

%(imports)s

#################### START OF CUSTOMIZED IMPORTS #####################
# Add additional imports in this block

##################### END OF CUSTOMIZED IMPORTS ######################


class %(table_name)sAggregateFactory(AggregateFactory.AggregateFactory):

    ###################### START OF AUTO-GENERATED CODE #####################

    def __init__( self,
                  proof_instance,
                  logger = None ):
        """ + '"""' + """ Constructor.

            @param proof_instance A ProofInstance object.
            @param logger A Logger object.
        """ + '"""' + """
        
        AggregateFactory.AggregateFactory.__init__( self,
                                                    proof_instance,
                                                    schema_name = "%(schema_name)s",
                                                    root_name   = "%(table_name)s",
                                                    logger      = logger )

%(function_list)s

    ####################### END OF AUTO-GENERATED CODE ######################

    ######################## START OF CUSTOMIZED CODE #######################

    # add your customized methods in this block
    # def xxx(self):
    #     pass
    
    ######################### END OF CUSTOMIZED CODE ########################
"""

REPOSITORY_TEMPLATE = """\
%(header)s

%(imports)s

#################### START OF CUSTOMIZED IMPORTS #####################
# Add additional imports in this block

##################### END OF CUSTOMIZED IMPORTS ######################


class %(table_name)sAggregateRepository(Repository.Repository):

    ###################### START OF AUTO-GENERATED CODE #####################

    def __init__( self,
                  proof_instance,
                  logger      = None
                  ):
        """ + '"""' + """ Constructor.

            @param proof_instance A ProofInstance object.
            @param logger A Logger object.
        """ + '"""' + """
                
        Repository.Repository.__init__( self,
                                        proof_instance,
                                        db_schema    = "%(schema_name)s",
                                        aggr_name    = "%(table_name)s",
                                        relation_map = {%(relation_map)s},
                                        logger       = logger )

%(function_list)s

    ####################### END OF AUTO-GENERATED CODE ######################

    ######################## START OF CUSTOMIZED CODE #######################

    # add your customized methods in this block
    # def xxx(self):
    #     pass
    
    ######################### END OF CUSTOMIZED CODE ########################
"""


class CodeGenerator:

    def __init__( self,
                  proof_path,
                  schemas,
                  python_path = '/python/path' ):
        """ Constructor.

            @param proof_path The relative path which is this Proof's root and can
                   be accessed from pythonpath.
            @param schemas A dictionary with database and aggregate info.
            @param python_path The python have to be included in sys.path when the
                   generated codes are used
        """
        self.__schemas     = schemas
        self.__proof_path  = proof_path

        if proof_path[0] == '/':
            raise Exception("Proof Path has to be a relative path")
        
        self.__root_path = os.path.join(python_path, proof_path)

    def process(self):
        
        for schema in self.__schemas:
            db_host      = schema['db_host']
            db_name      = schema['db_name']
            db_user      = schema['db_user']
            db_pass      = schema['db_pass']
            aggregates   = schema['aggregates']
            schema_name  = string.upper(db_name)

            scg = SchemaCodeGenerator( schema_name,
                                       db_host,
                                       db_name,
                                       db_user,
                                       db_pass,
                                       aggregates=aggregates )

            scg.process()

            # save code into gen dir
            code_path = self.__gen_path(schema_name)

            for table in scg.code.keys():
                for filename, code in scg.code[table].items():
                    open( os.path.join(code_path, filename), "w" ).write(code)
            

    def __gen_path(self, schema_name):
        """ Return gen path for one schema.
        """
        # make sure the basic path exists
        gen_path = os.path.join( self.__root_path,
                                 string.lower(schema_name),
                                 '_gen' )
        if not os.access(gen_path, os.F_OK):
            os.makedirs(gen_path)

        date = datetime.date.today().strftime('%Y%m%d')

        i = 0
        full_path = None
        while not full_path or os.access(full_path, os.F_OK):
            i += 1
            full_path = os.path.join( gen_path,
                                      "%s_%s" % (date, string.zfill(`i`, 3)) )
        os.mkdir(full_path)
        
        return full_path
    

class SchemaCodeGenerator:
    """ Generate class code for one database.
    """

    def __init__( self,
                  schema_name,
                  db_host,
                  db_name,
                  db_user,
                  db_pass,
                  aggregates = {},
                  ):
        self.__db_host     = db_host
        self.__db_name     = db_name
        self.__db_user     = db_user
        self.__db_pass     = db_pass

        self.con = MySQLConnection.MySQLConnection( host   = self.__db_host,
                                                    user   = self.__db_user,
                                                    passwd = self.__db_pass,
                                                    db     = self.__db_name )

        self.table_names = []
        self.tables      = []

        self.__aggregates  = aggregates
        self.__schema_name = schema_name

        # A dictionary to hold generated code, key is the filename of the code.
        self.code = {}

    def process(self):
        self.collect_tables()
        self.parse_tables()

        #print "Aggregate: %s\n" % (self.__aggregates)

        table2aggregate = {}
        for aggregate in self.__aggregates.keys():
            table2aggregate[aggregate] = aggregate
            for child in self.__aggregates[aggregate].keys():
                table2aggregate[child] = aggregate

        if len(table2aggregate.keys()) != len(self.tables):
            aggr_tables = table2aggregate.keys()
            aggr_tables.sort()
            db_tables = [ x[0] for x in self.tables ]
            db_tables.sort()
            missing_tables = []
            for table in db_tables:
                if table not in aggr_tables:
                    missing_tables.append(table)
            
            raise Exception( "Not all tables are included in aggregates:\n" + \
                             "Aggregated tables: \n%s\n" % (aggr_tables) + \
                             "Database tables: \n%s\n" % (db_tables) + \
                             "Missing tables: \n%s\n" % (missing_tables) )

        # hold child list for each aggregate
        child_list_dict = {}
        
        for table_name, column_dict in self.tables:
            self.code[table_name] = {}

            # object
            file_name, code = self.makeObject(table_name, column_dict)
            self.code[table_name][file_name] = code

            # objectfactory
            file_name, code = self.makeObjectFactory(table_name, column_dict)
            self.code[table_name][file_name] = code

            aggregate_name = table2aggregate[table_name]
            if table_name != aggregate_name:
                if not child_list_dict.has_key(aggregate_name):
                    child_list_dict[aggregate_name] = []
                child_list_dict[aggregate_name].append( [ table_name,
                                                          column_dict,
                                                          self.__aggregates[aggregate_name][table_name][1],
                                                          self.__aggregates[aggregate_name][table_name][2],
                                                          self.__aggregates[aggregate_name][table_name][3] ] )

        for table_name, column_dict in self.tables:

            if table_name not in self.__aggregates.keys():
                continue

            # aggregate
            file_name, code = self.makeAggregate(table_name, column_dict, child_list_dict.get(table_name, None))
            self.code[table_name][file_name] = code
            
            # aggregatefactory
            file_name, code = self.makeAggregateFactory(table_name, column_dict, child_list_dict.get(table_name, None))
            self.code[table_name][file_name] = code

            # repository
            file_name, code = self.makeRepository(table_name, column_dict, child_list_dict.get(table_name, None))
            self.code[table_name][file_name] = code
    

    def collect_tables(self):
        """ Collect all tables in the database.
        """
        sql = "show tables"
        cursor = self.con.cursor()
        cursor.query(sql)
        result = cursor.fetchall()
        for row in result:
            self.table_names.append(row[0])

    def parse_tables(self):
        """ Parse all tables.
        """
        cursor = self.con.cursor()
        for table in self.table_names:
            sql = "desc `%s`" % (table)
            cursor.query(sql)
            result = cursor.fetchall()

            #sys.stderr.write(`result`)
            self.tables.append( [table, self.parse_columns(result)] )

    def parse_columns(self, column_list):
        """ Parse columns in the table.
        
            Required fields for each column are:
            <type>varchar</type>
            <size>25</size>
            <pk>false</pk>
            <notnull>true</notnull>
            <fktable>none</fktable>
            <fkcolumn>none</fkcolumn>

            @param column_list A list of columns with these attributes:
                   Field, Type, Null, Key, Default, Extra
        """
        columns = []

        for column in column_list:
            name    = string.strip(column[0])
            typestr = string.strip(column[1])
            isnull  = string.strip(column[2])
            key     = string.strip(column[3])
            default = column[4]
            values  = None
            
            type_name = typestr
            size = 0

            m = re.match("^([^(]+)\((.*?)\)$", typestr)
            if m:
                type_name = m.group(1)
                # only varchar/char size make sense
                if type_name in ( 'varchar', 'char' ):
                    size = m.group(2)
                elif type_name in ('enum', 'set'):
                    values = m.group(2)

            if isnull == 'YES':
                notnull = 'false'
            else:
                notnull = 'true'

            if key == 'PRI':
                pk = 'true'
            else:
                pk = 'false'

            # guess foreign key
            # assume all primary keys are 'Id'
            # all foreign keys should follow the pattern: <table_name>Id
            fktable  = 'none'
            fkcolumn = 'none'
            if re.match(".+Id$", name):
                fkt = name[:-2]
                if fkt in self.table_names:
                    fktable  = fkt
                    fkcolumn = 'Id'

            columns.append( [ name, { 'type'     : type_name,
                                      'size'     : size,
                                      'pk'       : pk,
                                      'notnull'  : notnull,
                                      'fktable'  : fktable,
                                      'fkcolumn' : fkcolumn,
                                      'values'   : values,
                                      'default'  : default
                                      } ] )
            
        return columns

    def makeObject(self, table_name, column_list):

        file_name   = "%s.py" % (table_name)
        file_header = "%s\n%s" % (file_name, '='*len(file_name))
        description = OBJECT_DESCRIPTION % { 'file_header' : file_header }
        header      = CODE_TEMPLATE_HEADER % { 'description' : description }

        lib_imports   = UniqueList.UniqueList()
        dpm_imports   = UniqueList.UniqueList()
        proof_imports = UniqueList.UniqueList()
        function_list = []

        proof_imports.append( "import proof.BaseObject as BaseObject" )

        for column_name, column_dict in column_list:
            if string.lower(column_name) == 'id':
                continue

            pytype_str = self.__sql2py_type_str(column_dict)
            
            func_name = self.__func_name(column_name, column_dict)
            if func_name == column_name:
                # get method always same
                function_list.append( "    def get%s(self):\n" % (func_name) + \
                                      "        " + '"""' + " Get %s.\n" % (func_name) + \
                                      "        \n" + \
                                      "            @return %s.\n" % (pytype_str) + \
                                      "        " + '"""' + "\n" + \
                                      "        return self.__getitem__('%s')" % (column_name) )
                # set method
                var_name = self.__var_name(column_name, column_dict)
                if column_dict['type'] == 'enum':
                    lib_imports.append("import logging")
                    # need check available values
                    function_list.append( "    def set%s(self, %s):\n" % (func_name, var_name) + \
                                          "        " + '"""' + " Set %s without updating to the live database. The aggregate should\n" % (func_name) + \
                                          "            handle updates all together.\n" + \
                                          "            Note: enum type should check all possible values.\n" + \
                                          "        \n" + \
                                          "            @param %s %s.\n" % (var_name, pytype_str) + \
                                          "        " + '"""' + "\n" + \
                                          "        if %s in [%s]:\n" % (var_name, column_dict['values']) + \
                                          "            self.__setitem__('%s', %s)\n" % (column_name, var_name) + \
                                          "        else:\n" + \
                                          "            self.log( \""+ func_name +" value '%s' is not valid.\" % " + "(%s), logging.WARNING )" % (var_name) )

                # timestamp doesn't need set method
                elif column_dict['type'] != 'timestamp':
                    function_list.append( "    def set%s(self, %s):\n" % (func_name, var_name) + \
                                          "        " + '"""' + " Set %s without updating to the live database. The aggregate should\n"  % (func_name) + \
                                          "            handle updates all together.\n" + \
                                          "        \n" + \
                                          "            @param %s %s.\n" % (var_name, pytype_str) + \
                                          "        " + '"""' + "\n" + \
                                          "        self.__setitem__('%s', %s)" % (column_name, var_name) )
            else:
                # aggregate column
                proof_imports.append( "import proof.pk.ObjectKey as ObjectKey" )
                proof_imports.append( "import proof.Aggregate as Aggregate" )

                var_name = self.__var_name(column_name, column_dict)

                # get method
                function_list.append( "    def get%s(self):\n" % (func_name) + \
                                      "        " + '"""' + " Get %s.\n" % (func_name) + \
                                      "        \n" + \
                                      "            @return %s.\n" % (pytype_str) + \
                                      "        " + '"""' + "\n" + \
                                      "        %s_id = self.__getitem__('%s')\n" % (var_name, column_name) + \
                                      "\n" + \
                                      "        pk = ObjectKey.ObjectKey(%s_id, column_name='%s.Id')\n" % (var_name, func_name) + \
                                      "        proof = self.getAggregate().getProofInstance()\n" + \
                                      "        repository = proof.getInstanceForRepository( '%s', schema=self.getDBSchema() )\n" % (func_name) + \
                                      "\n" + \
                                      "        return repository.getByPK(pk)" )

                # set method
                if column_dict['notnull'] == 'true':
                    function_list.append( "    def set%s(self, %s):\n" % (func_name, var_name) + \
                                          "        " + '"""' + " Set %s without updating to the live database. The aggregate should\n"  % (func_name) + \
                                          "            handle updates all together.\n" + \
                                          "        \n" + \
                                          "            @param %s %s.\n" % (var_name, pytype_str) + \
                                          "        " + '"""' + "\n" + \
                                          "        assert issubclass(%s.__class__, Aggregate.Aggregate) and \\\n" % (var_name) + \
                                          "               %s.__class__.__name__ == '%sAggregate'\n" % (var_name, func_name) + \
                                          "\n" + \
                                          "        pk = %s.getPK()\n" % (var_name) + \
                                          "        self.__setitem__('%s', pk.getValue())" % (column_name) )
                else:
                    function_list.append( "    def set%s(self, %s):\n" % (func_name, var_name) + \
                                          "        " + '"""' + " Set %s without updating to the live database. The aggregate should\n"  % (func_name) + \
                                          "            handle updates all together.\n" + \
                                          "        \n" + \
                                          "            @param %s %s.\n" % (var_name, pytype_str) + \
                                          "        " + '"""' + "\n" + \
                                          "        id = 0\n" + \
                                          "        if %s:\n" % (var_name) + \
                                          "            assert issubclass(%s.__class__, Aggregate.Aggregate) and \\\n" % (var_name) + \
                                          "                   %s.__class__.__name__ == '%sAggregate'\n" % (var_name, func_name) + \
                                          "            id = %s.getPK().getValue()\n" % (var_name) + \
                                          "\n" + \
                                          "        self.__setitem__('%s', id)" % (column_name) )
        
        imports = ''
        if len(lib_imports) > 0:
            imports += "%s\n\n" % (string.join(lib_imports, "\n"))

        if len(dpm_imports) > 0:
            imports += "%s\n\n" % (string.join(dpm_imports, "\n"))

        if len(proof_imports) > 0:
            imports += "%s\n\n" % (string.join(proof_imports, "\n"))

        return file_name, OBJECT_TEMPLATE % { 'header'        : header,
                                              'imports'       : imports,
                                              'table_name'    : table_name,
                                              'schema_name'   : self.__schema_name,
                                              'function_list' : string.join(function_list, "\n\n") }
    

    def makeObjectFactory(self, table_name, column_list):

        file_name   = "%sFactory.py" % (table_name)
        file_header = "%s\n%s" % (file_name, '='*len(file_name))
        description = OBJECT_FACTORY_DESCRIPTION % { 'file_header' : file_header }
        header      = CODE_TEMPLATE_HEADER % { 'description' : description }

        imports = "import proof.ObjectFactory as ObjectFactory"

        return file_name, OBJECT_FACTORY_TEMPLATE % { 'header'        : header,
                                                      'imports'       : imports,
                                                      'table_name'    : table_name,
                                                      'schema_name'   : self.__schema_name }


    def makeAggregate(self, table_name, column_list, children_list=None):
        """ Create code for an aggregate.

            @param table_name The root name.
            @param column_list The column detailed info.
            @param children_list A list of child tables specs
                   [(tablename,column_list,join_column,'1'/'n',n_column)]
        """

        root_name   = table_name
        file_name   = "%sAggregate.py" % (table_name)
        file_header = "%s\n%s" % (file_name, '='*len(file_name))
        description = AGGREGATE_DESCRIPTION % { 'file_header' : file_header }
        header      = CODE_TEMPLATE_HEADER % { 'description' : description }

        table_list  = self.__recontruct_tables(table_name, column_list, children_list)

        lib_imports   = UniqueList.UniqueList()
        dpm_imports   = UniqueList.UniqueList()
        proof_imports = UniqueList.UniqueList()
        function_list = []

        proof_imports.append( "import proof.Aggregate as Aggregate" )

        for table_spec in table_list:
            (table_name, column_list, join_column, join_type, type_column) = table_spec

            type_columns = string.split(type_column, '+')

            if table_name != root_name:
                # internal getObject method
                if join_type == '1':
                    lib_imports.append( "import logging" )
                    function_list.append( "    def __get%sObject(self):\n" % (table_name) + \
                                          "        " + '"""' + " Internal method used to query %s object contained in this\n" % (table_name) + \
                                          "        " + "     %sAggregate.\n" % (root_name) + \
                                          "        " + '"""' + "\n" + \
                                          "        %s_list = self.getObjects('%s')\n" % (string.lower(table_name), table_name) + \
                                          "        if not %s_list:\n" % (string.lower(table_name)) + \
                                          "            self.load()\n" + \
                                          "            %s_list = self.getObjects('%s')\n" % (string.lower(table_name), table_name) + \
                                          "        \n" + \
                                          "        if %s_list:\n" % (string.lower(table_name)) + \
                                          "            return %s_list[0]\n" % (string.lower(table_name)) + \
                                          "        else:\n" + \
                                          "            self.log( \"%s doesn't exist for %s" % (table_name, root_name) + " '%s'\" % (str(self.getPK())), logging.ERROR )\n" + \
                                          "            return None" )

            nchild_var_names   = []
            nchild_params      = []
            nchild_if_list     = []
            nchild_key_maxlen  = 0
            nchild_get_list    = []
            nchild_set_list1   = []
            nchild_set_list21  = []
            nchild_set_list22  = []
            
            for column_name, column_dict in column_list:
                if string.lower(column_name) == 'id':
                    continue
            
                pytype_str = self.__sql2py_type_str(column_dict)
            
                func_name = self.__func_name(column_name, column_dict)
                var_name = self.__var_name(column_name, column_dict)

                if table_name == root_name:

                    # get method
                    function_list.append( "    def get%s(self):\n" % (func_name) + \
                                          "        " + '"""' + " Get %s.\n" % (func_name) + \
                                          "        \n" + \
                                          "            @return %s.\n" % (pytype_str) + \
                                          "        " + '"""' + "\n" + \
                                          "        return self.getRoot().get%s()" % (func_name) )

                    # set method
                    if column_dict['type'] != 'timestamp':
                        function_list.append( "    def set%s(self, %s):\n" % (func_name, var_name) + \
                                              "        " + '"""' + " Set %s without updating to the live database. The application should\n"  % (func_name) + \
                                              "            handle updates all together.\n" + \
                                              "        \n" + \
                                              "            @param %s %s.\n" % (var_name, pytype_str) + \
                                              "        " + '"""' + "\n" + \
                                              "        self.getRoot().set%s(%s)" % (func_name, var_name) )

                else:

                    if join_type == '1':

                        if join_column != column_name:
                            # get method
                            function_list.append( "    def get%s%s(self):\n" % (table_name, func_name) + \
                                                  "        " + '"""' + " Get %s %s.\n" % (table_name, func_name) + \
                                                  "        \n" + \
                                                  "            @return %s.\n" % (pytype_str) + \
                                                  "        " + '"""' + "\n" + \
                                                  "        %s = self.__get%sObject()\n" % (string.lower(table_name), table_name) + \
                                                  "        if %s:\n" % (string.lower(table_name)) + \
                                                  "            return %s.get%s()\n" % (string.lower(table_name), func_name) + \
                                                  "        return None" )
                            
                            # set method
                            if column_dict['type'] != 'timestamp':
                                
                                function_list.append( "    def set%s%s(self, %s):\n" % (table_name, func_name, var_name) + \
                                                      "        " + '"""' + " Set %s %s without updating to the live database. The application\n"  % (table_name, func_name) + \
                                                      "            should handle updates all together.\n" + \
                                                      "        \n" + \
                                                      "            @param %s %s.\n" % (var_name, pytype_str) + \
                                                      "        " + '"""' + "\n" + \
                                                      "        %s = self.__get%sObject()\n" % (string.lower(table_name), table_name) + \
                                                      "        if %s:\n" % (string.lower(table_name)) + \
                                                      "            %s.set%s(%s)" % (string.lower(table_name), func_name, var_name) )
                            
                    elif join_type == 'n':

                        if column_name in type_columns:

                            nchild_var_names.append( var_name )
                            nchild_params.append( "@param %s %s." % (var_name, pytype_str) )
                            nchild_if_list.append( "%s.get%s() == %s" % (string.lower(table_name), func_name, var_name) )
                            
                        # add columns
                        if column_name not in type_columns and join_column != column_name:
                            nchild_get_list.append( [ "'%s'" % (func_name),
                                                      "%s.get%s()" % (string.lower(table_name), func_name) ] )

                            if nchild_key_maxlen < (len(func_name)+2):
                                nchild_key_maxlen = len(func_name)+2
                            
                            # skip unnecessary columns
                            if func_name not in ['CreateTime', 'UpdateTime']:
                                if column_dict['notnull'] == 'true':
                                    nchild_set_list1.append( "%s.set%s( %s_dict['%s'] )" % \
                                                             ( string.lower(table_name),
                                                               func_name,
                                                               string.lower(table_name),
                                                               func_name ) )
                                else:
                                    nchild_set_list1.append( "%s.set%s( %s_dict.get('%s', None) )" % \
                                                             ( string.lower(table_name),
                                                               func_name,
                                                               string.lower(table_name),
                                                               func_name ) )

                        if join_column != column_name:
                            if column_name in type_columns:
                                nchild_set_list21.append( var_name )
                            elif column_dict['notnull'] == 'true':
                                # the signature has to be same with AggregateFactory
                                if column_dict['type'] == 'datetime':
                                    lib_imports.append( "import datetime" )
                                    nchild_set_list22.append( "%s = %s_dict.get('%s', datetime.datetime.now().__str__())" % \
                                                              ( var_name, string.lower(table_name), func_name ) )
                                elif column_dict['type'] == 'date':
                                    lib_imports.append( "import datetime" )
                                    nchild_set_list22.append( "%s = %s_dict.get('%s', datetime.date.today().__str__())" % \
                                                              ( var_name, string.lower(table_name), func_name ) )
                                elif column_dict['type'] in ('enum', 'set') and column_dict['default']:
                                    nchild_set_list22.append( "%s = %s_dict.get('%s', '%s')" % \
                                                              ( var_name, string.lower(table_name), 
                                                                func_name, column_dict['default'] ) )
                                else:
                                    nchild_set_list21.append( "%s_dict['%s']" % \
                                                              ( string.lower(table_name),
                                                                func_name ) )
                            else:
                                if column_dict['type'] == 'datetime':
                                    lib_imports.append( "import datetime" )
                                    nchild_set_list22.append( "%s = %s_dict.get('%s', datetime.datetime.now().__str__())" % \
                                                              ( var_name, string.lower(table_name), func_name ) )
                                elif column_dict['type'] == 'date':
                                    lib_imports.append( "import datetime" )
                                    nchild_set_list22.append( "%s = %s_dict.get('%s', datetime.datetime.today().__str__())" % \
                                                              ( var_name, string.lower(table_name), func_name ) )
                                elif column_dict['type'] != 'timestamp':
                                    if type(column_dict['default']) == type(''):
                                        value = "'%s'" % (column_dict['default'])
                                    else:
                                        value = column_dict['default']
                                    nchild_set_list22.append( "%s = %s_dict.get('%s', %s)" % \
                                                              ( var_name,
                                                                string.lower(table_name),
                                                                func_name,
                                                                value ) )
             
            # n child get method
            if table_name != root_name:
                if join_type == 'n':
                    # internal getObject method
                            
                    function_list.append( "    def __get%sObject(self, %s):\n" % (table_name, string.join(nchild_var_names, ", ")) + \
                                          "        " + '"""' + " Query a(n) %s object in %sAggregate.\n" % (table_name, root_name) + \
                                          "        \n" + \
                                          "            %s\n" % (string.join(nchild_params, "\n            ")) + \
                                          "            \n" + \
                                          "            @return A(n) %s object or None if not found.\n" % (table_name) + \
                                          "        " + '"""' + "\n" + \
                                          "        %s_list = self.getObjects('%s')\n" % (string.lower(table_name), table_name) + \
                                          "        if not %s_list:\n" % (string.lower(table_name)) + \
                                          "            self.load()\n" + \
                                          "            %s_list = self.getObjects('%s')\n" % (string.lower(table_name), table_name) + \
                                          "        \n" + \
                                          "        for %s in %s_list:\n" % (string.lower(table_name), string.lower(table_name)) + \
                                          "            if %s:\n" % (string.join(nchild_if_list, " and ")) + \
                                          "                return %s\n" % (string.lower(table_name)) + \
                                          "        \n" + \
                                          "        return None" )

                    get_dict_str = ''
                    for column, value in nchild_get_list:
                        key_str = "%s%s" % (column, " "*(nchild_key_maxlen-len(column)))
                        get_dict_str += "%s : %s,\n%s" % (key_str, value, " "*21)
            
                    function_list.append( "    def get%s(self, %s):\n" % (table_name, string.join(nchild_var_names, ", ")) + \
                                          "        " + '"""' + " A wraper to %s object.\n" % (table_name) + \
                                          "        \n" + \
                                          "            @return A dict with column names as keys.\n" + \
                                          "            %s\n" % (string.join(nchild_params, "\n            ")) + \
                                          "            \n" + \
                                          "        " + '"""' + "\n" + \
                                          "        %s = self.__get%sObject(%s)\n" % (string.lower(table_name),table_name,string.join(nchild_var_names, ", ")) + \
                                          "        if %s:\n" % (string.lower(table_name)) + \
                                          "            return { %s}\n" % (get_dict_str) + \
                                          "        else:\n" + \
                                          "            self.log( \"Can't find %s in %sAgggregate" % (table_name, root_name) + " '%s'\" % (str(self.getPK())) )\n" + \
                                          "            return {}" )
            
                    # n child set method
                    # avoid empty list
                    if not nchild_set_list1:
                        nchild_set_list1.append("pass")
                    
                    function_list.append( "    def set%s(self, %s, %s_dict):\n" % (table_name, string.join(nchild_var_names, ", "), string.lower(table_name)) + \
                                          "        " + '"""' + " A wraper to %s object.\n" % (table_name) + \
                                          "        \n" + \
                                          "            %s\n" % (string.join(nchild_params, "\n            ")) + \
                                          "            @param %s_dict A dict with %s column names as keys.\n" % (string.lower(table_name), table_name) + \
                                          "        " + '"""' + "\n" + \
                                          "        %s = self.__get%sObject(%s)\n" % (string.lower(table_name), table_name, string.join(nchild_var_names, ", ")) + \
                                          "        if %s:\n" % (string.lower(table_name)) + \
                                          "            %s\n" % (string.join(nchild_set_list1, "\n%s"%(" "*12))) + \
                                          "        else:\n" + \
                                          "            self.log( \"Can't find %s for %s "%(table_name,root_name) + "'%s'. Trying to create one ...\" % \\\n" + \
                                          "                      (str(self.getPK())) )\n" + \
                                          "            proof = self.getProofInstance()\n" + \
                                          "            factory = proof.getInstanceForAggregateFactory( self.getRootName(),\n" + \
                                          "                                                            schema=self.getDBSchema() )\n" + \
                                          "            factory.create%s( self,\n" % (table_name) + \
                                          "                            %s%s )\n" % ( " "*len(table_name),
                                                                                     string.join(nchild_set_list21+nchild_set_list22, ",\n%s"%(" "*(28+len(table_name)))) ) ) 

        imports = ''
        if len(lib_imports) > 0:
            imports += "%s\n\n" % (string.join(lib_imports, "\n"))

        if len(dpm_imports) > 0:
            imports += "%s\n\n" % (string.join(dpm_imports, "\n"))

        if len(proof_imports) > 0:
            imports += "%s\n\n" % (string.join(proof_imports, "\n"))

        return file_name, AGGREGATE_TEMPLATE % { 'header'        : header,
                                                 'imports'       : imports,
                                                 'table_name'    : root_name,
                                                 'schema_name'   : self.__schema_name,
                                                 'function_list' : string.join(function_list, "\n\n") }
        

    def makeAggregateFactory(self, table_name, column_list, children_list=None):
        """ Create code for an aggregate factory.

            @param table_name The root name.
            @param column_list The column detailed info.
            @param children_list A list of child tables specs
                   [(tablename,column_list,join_column,'1'/'n',n_column)]
        """

        root_name   = table_name        
        file_name   = "%sAggregateFactory.py" % (table_name)
        file_header = "%s\n%s" % (file_name, '='*len(file_name))
        description = AGGREGATE_FACTORY_DESCRIPTION % { 'file_header' : file_header,
                                                        'table_name'  : root_name }
        header      = CODE_TEMPLATE_HEADER % { 'description' : description }
        
        table_list  = self.__recontruct_tables(table_name, column_list, children_list)

        lib_imports   = UniqueList.UniqueList()
        dpm_imports   = UniqueList.UniqueList()
        proof_imports = UniqueList.UniqueList()

        proof_imports.append( "import proof.AggregateFactory as AggregateFactory" )

        function_list = []

        root_function_str   = ""
        root_addin_vars     = []
        root_addin_params   = []
        root_relate_objects = []
        join_var_name = ""
        
        for table_spec in table_list:
            (table_name, column_list, join_column, join_type, type_column) = table_spec

            type_columns = string.split(type_column, '+')
            
            if table_name != root_name:
                root_addin_vars.append( "%s_dict_list = [],\n%s" % (string.lower(table_name), " "*16) )
                root_addin_params.append( """@param %(lower_table_name)s_dict_list A list of %(table_name)s data saved as dict with
                   %(table_name)s columns as keys.
            """ % { 'lower_table_name' : string.lower(table_name),
                    'table_name'       : table_name } )

            create_vars = []
            create_default_vars = []
            max_var_length = 0
            max_column_name_len = 0
            
            id_name       = ''
            id_list       = []
            data_col_list = []
            
            child_var_list = []
            child_default_var_list = []
            missing_default_list = []

            for column_name, column_dict in column_list:
                if string.lower(column_name) == 'id':
                    id_name = column_name
                    continue
            
                pytype_str = self.__sql2py_type_str(column_dict)
                
                func_name = self.__func_name(column_name, column_dict)
                var_name = self.__var_name(column_name, column_dict)
                if len(var_name) > max_var_length:
                    max_var_length = len(var_name)
                
                if column_name == join_column:
                    join_var_name = var_name
                
                if column_name in type_columns:
                    if column_dict['fktable'] != 'none' and \
                           column_dict['fktable'] in self.__aggregates.keys():
                        if column_name == join_column:
                            create_vars.insert(0, [var_name, 'obj', pytype_str] )
                            id_list.insert( 0, "%s_id = %s.getPK().getValue()" % (var_name, var_name) )
                        else:
                            create_vars.append([var_name, 'obj', pytype_str] )
                            id_list.append( "%s_id = %s.getPK().getValue()" % (var_name, var_name) )
                            child_var_list.append( "%s_dict['%s']" % ( string.lower(table_name),
                                                                       func_name ) )
                        var_name = "%s_id" % (var_name)
                    else:
                        create_vars.append([var_name, '', pytype_str])
                        child_var_list.append( "%s_dict['%s']" % ( string.lower(table_name),
                                                                   func_name ) )
                                
                elif column_dict['notnull'] == 'true':
                    if column_dict['fktable'] != 'none' and \
                           column_dict['fktable'] in self.__aggregates.keys():
                        if column_name == join_column:
                            create_vars.insert(0, [var_name, 'obj', pytype_str] )
                            id_list.insert( 0, "%s_id = %s.getPK().getValue()" % (var_name, var_name) )
                        else:
                            create_vars.append([var_name, 'obj', pytype_str] )
                            id_list.append( "%s_id = %s.getPK().getValue()" % (var_name, var_name) )
                            child_var_list.append( "%s_dict['%s']" % ( string.lower(table_name),
                                                                       func_name ) )
                        var_name = "%s_id" % (var_name)
                    elif column_dict['type'] == 'datetime':
                        lib_imports.append( "import datetime" )
                        #create_default_vars.append( [var_name, 'datetime.datetime.now().__str__()', pytype_str] )
                        create_default_vars.append( [var_name, 'None', pytype_str] )
                        child_default_var_list.append( "%s = %s_dict.get('%s', datetime.datetime.now().__str__())" % ( var_name,
                                                                                                                       string.lower(table_name),
                                                                                                                       func_name ) )
                        missing_default_list.append("if %s is None: %s = datetime.datetime.now().__str__()"%(var_name, var_name))
                    elif column_dict['type'] == 'date':
                        lib_imports.append( "import datetime" )
                        #create_default_vars.append( [var_name, 'datetime.date.today().__str__()', pytype_str] )
                        create_default_vars.append( [var_name, 'None', pytype_str] )
                        child_default_var_list.append( "%s = %s_dict.get('%s', datetime.date.today().__str__())" % ( var_name,
                                                                                                                     string.lower(table_name),
                                                                                                                     func_name ) )
                        missing_default_list.append("if %s is None: %s = datetime.datetime.today().__str__()"%(var_name, var_name))
                    elif column_dict['type'] in ('enum', 'set') and column_dict['default']:
                        create_default_vars.append( [var_name, "'%s'"%(column_dict['default']), pytype_str] )
                        child_default_var_list.append( "%s = %s_dict.get('%s', '%s')" % ( var_name,
                                                                                          string.lower(table_name),
                                                                                          func_name,
                                                                                          column_dict['default'] ) )
                    elif column_dict['type'] != 'timestamp':
                        create_vars.append([var_name, '', pytype_str])
                        child_var_list.append( "%s_dict['%s']" % ( string.lower(table_name),
                                                                   func_name ) )
                
                else:
                    if column_dict['fktable'] != 'none' and \
                           column_dict['fktable'] in self.__aggregates.keys():
                        create_default_vars.append([var_name, 'None', pytype_str] )
                        id_list.insert( 0, "    %s_id = 0" % (var_name) )
                        id_list.insert( 0, "else:" )
                        id_list.insert( 0, "    %s_id = %s.getPK().getValue()" % (var_name, var_name) )
                        id_list.insert( 0, "if %s:" % (var_name) )
                        if column_name != join_column:
                            child_default_var_list.append( "%s = %s_dict.get('%s', 0)" % ( var_name,
                                                                                           string.lower(table_name),
                                                                                           func_name ) )
                        var_name = "%s_id" % (var_name)
                    
                    elif column_dict['type'] == 'datetime':
                        lib_imports.append( "import datetime" )
                        #create_default_vars.append( [var_name, 'datetime.datetime.now().__str__()', pytype_str] )
                        create_default_vars.append( [var_name, 'None', pytype_str] )
                        child_default_var_list.append( "%s = %s_dict.get('%s', datetime.datetime.now().__str__())" % ( var_name,
                                                                                                                       string.lower(table_name),
                                                                                                                       func_name ) )
                        missing_default_list.append("if %s is None: %s = datetime.datetime.now().__str__()"%(var_name, var_name))
                    elif column_dict['type'] == 'date':
                        lib_imports.append( "import datetime" )
                        #create_default_vars.append( [var_name, 'datetime.date.today().__str__()', pytype_str] )
                        create_default_vars.append( [var_name, 'None', pytype_str] )
                        child_default_var_list.append( "%s = %s_dict.get('%s', datetime.date.today().__str__())" % ( var_name,
                                                                                                                     string.lower(table_name),
                                                                                                                     func_name ) )
                        missing_default_list.append("if %s is None: %s = datetime.datetime.today().__str__()"%(var_name, var_name))
                    elif column_dict['type'] != 'timestamp':
                        if type(column_dict['default']) == type(''):
                            value = "'%s'" % (column_dict['default'])
                        else:
                            value = column_dict['default']
                        create_default_vars.append( [var_name, value, pytype_str] )
                        child_default_var_list.append( "%s = %s_dict.get('%s', %s)" % ( var_name,
                                                                                        string.lower(table_name),
                                                                                        func_name,
                                                                                        value ) )
                
                if column_dict['type'] == 'timestamp':
                    data_col_list.append( ["'%s.%s'" % (table_name, column_name), 'None'] )
                else:
                    data_col_list.append( ["'%s.%s'" % (table_name, column_name), var_name] )

                if len("'%s.%s'" % (table_name, column_name)) > max_column_name_len:
                    max_column_name_len = len("'%s.%s'" % (table_name, column_name))

            child_var_list += child_default_var_list

            if table_name != root_name:
                root_relate_objects.append( """\
        # %(table_name)s
        for %(lower_table_name)s_dict in %(lower_table_name)s_dict_list:
            aggregate = self.create%(table_name)s( aggregate,
                                     %(space)s%(vars)s )""" % { 'table_name'       : table_name,
                                                                'lower_table_name' : string.lower(table_name),
                                                                'space'            : " "*len(table_name),
                                                                'vars'             : string.join(child_var_list, ",\n%s"%(" "*(37+len(table_name)))) } )

            identity = ''
            if table_name != root_name:
                identity = table_name

            # vars
            vars = ""
            default_vars = ""
            params = ""
            default_params = ""
            for var_name, var_type, pytype_str in create_vars:
                vars += "%s%s,\n%s" % (" "*len(identity), var_name, " "*16)
                params += "@param %s %s.\n%s" % (var_name, pytype_str, " "*12)

            for var_name, value, pytype_str in create_default_vars:
                default_vars += "%s%s%s = %s,\n%s" % (" "*len(identity), var_name, " "*(max_var_length-len(var_name)), value, " "*16)
                default_params += "@param %s %s (optional).\n%s" % (var_name, pytype_str, " "*12)

            default_vars += " "*len(identity)

            # id list
            object_ids = string.join(id_list, "\n%s" % (" "*8))
            
            # missing defaults
            missing_defaults = string.join(missing_default_list, "\n%s" % (" "*8))

            # table data
            table_data = ""
            for col, var_name in data_col_list:
                table_data += "%s%s : %s,\n%s" % (col, " "*(max_column_name_len-len(col)), var_name, " "*(18+len(table_name)))

            if table_name == root_name:
                comment = '"""' + """ Create a(n) %(table_name)sAggregate.

            %(params)s<<addin_params>>%(default_params)s
            @return A(n) %(table_name)sAggregate object.
        """ % { 'table_name'     : table_name, 
                'params'         : params,
                'default_params' : default_params } + '"""'

            else:
                comment = '"""' + """ Create a(n) %(table_name)s in %(root_name)sAggregate.

            %(params)s%(default_params)s
            @return A(n) %(root_name)sAggregate object.
        """ % { 'table_name'     : table_name,
                'root_name'      : root_name,
                'params'         : params,
                'default_params' : default_params } + '"""'
                
            function_str = """\
    def create%(identity)s( self,
                %(vars)s<<addin_vars>>%(default_vars)s):
        %(comment)s
        
        # construct data dict
        %(object_ids)s
        
        %(missing_defaults)s
        
        %(low_table_name)s_data = { %(table_data)s}
        
        # create the object
        id = self._create(%(low_table_name)s_data)""" % { 'identity'         : identity,
                                                          'vars'             : vars,
                                                          'default_vars'     : default_vars,
                                                          'table_data'       : table_data,
                                                          'object_ids'       : object_ids,
                                                          'missing_defaults' : missing_defaults,
                                                          'comment'          : comment,
                                                          'low_table_name'   : string.lower(table_name) }

            if table_name == root_name:
                function_str += """\

        %(low_table_name)s_data['%(table_name)s.%(id_name)s'] = id

        # create the aggregate
        aggregate = self.constructAggregate(%(low_table_name)s_data)

        # create more related objects when necessary
<<relate_objects>>

        # return the aggregate
        return aggregate""" % { 'table_name'     : table_name,
                                'id_name'        : id_name,
                                'low_table_name' : string.lower(table_name) }
            else:
                proof_imports.append("import proof.pk.ObjectKey as ObjectKey")

                function_str += """\

        pk = ObjectKey.ObjectKey(id, '%(table_name)s.%(id_name)s')
        %(low_table_name)s = self._makeObject(%(join_var_name)s, '%(table_name)s', pk)
        %(low_table_name)s.initialize(%(low_table_name)s_data)

        # add to the aggregate
        %(join_var_name)s.addObject('%(table_name)s', %(low_table_name)s)

        return %(join_var_name)s""" % { 'table_name'     : table_name,
                                        'id_name'        : id_name,
                                        'low_table_name' : string.lower(table_name),
                                        'join_var_name'  : join_var_name }

            if table_name != root_name:
                function_str = function_str.replace("<<addin_params>>", "")
                function_str = function_str.replace("<<addin_vars>>", "")
                function_list.append( function_str )
            else:
                root_function_str = function_str
        
        # add addin in root function
        root_function_str = root_function_str.replace("<<addin_vars>>", string.join(root_addin_vars, ''))
        root_function_str = root_function_str.replace("<<addin_params>>", string.join(root_addin_params, ''))
        root_function_str = root_function_str.replace("<<relate_objects>>", string.join(root_relate_objects, "\n\n"))

        function_list.insert(0, root_function_str)

        imports = ''
        if len(lib_imports) > 0:
            imports += "%s\n\n" % (string.join(lib_imports, "\n"))

        if len(dpm_imports) > 0:
            imports += "%s\n\n" % (string.join(dpm_imports, "\n"))

        if len(proof_imports) > 0:
            imports += "%s\n\n" % (string.join(proof_imports, "\n"))

        return file_name, AGGREGATE_FACTORY_TEMPLATE % { 'header'        : header,
                                                         'imports'       : imports,
                                                         'table_name'    : root_name,
                                                         'schema_name'   : self.__schema_name,
                                                         'function_list' : string.join(function_list, "\n\n"), }

    def makeRepository(self, table_name, column_list, children_list=None):
        """ Create code for a repository.

            @param table_name The root name.
            @param column_list The column detailed info.
            @param children_list A list of child tables specs
                   [(tablename,column_list,join_column,'1'/'n',n_column)]
        """

        root_name   = table_name
        file_name   = "%sAggregateRepository.py" % (table_name)
        file_header = "%s\n%s" % (file_name, '='*len(file_name))
        description = REPOSITORY_DESCRIPTION % { 'file_header' : file_header,
                                                 'table_name'  : root_name }
        header      = CODE_TEMPLATE_HEADER % { 'description' : description }
        
        table_list  = self.__recontruct_tables(table_name, column_list, children_list)

        lib_imports   = UniqueList.UniqueList()
        dpm_imports   = UniqueList.UniqueList()
        proof_imports = UniqueList.UniqueList()

        lib_imports.append( "import string" )
        
        proof_imports.append( "import proof.sql.Criteria as Criteria" )
        proof_imports.append( "import proof.sql.SQLConstants as SQLConstants" )
        proof_imports.append( "import proof.Repository as Repository" )
        
        # struct relation map
        relation_list = []
        relation_key_maxlen = 0
        relation_map = ''
        if children_list:
            for (table, column_list, join_column, join_type, type_column) in children_list:
                relation_list.append(["'%s'" % (table), "[['%s.Id'], ['%s.%s']]"%(root_name,table,join_column)])
                if relation_key_maxlen < (len(table) + 2):
                    relation_key_maxlen = len(table) + 2

        for key, value in relation_list:
            relation_map += "%s%s : %s,\n%s" % (key, " "*(relation_key_maxlen-len(key)), value, " "*56)

        # byany
        byany_var_list  = []
        byany_crit_list = []
        byany_max_var_length = 0

        # function list
        function_list = []
        
        for table_spec in table_list:
            (table_name, column_list, join_column, join_type, type_column) = table_spec

            var_list  = []
            crit_list = []
            max_var_length = 0

            if children_list:
                function_list.append( """\
    ###%s##
    #  %s  """ % ("#"*len(table_name), table_name) )

            for column_name, column_dict in column_list:
                if string.lower(column_name) == 'id':
                    continue

                if column_name == join_column:
                    continue

                pytype_str = self.__sql2py_type_str(column_dict)
            
                func_name = self.__func_name(column_name, column_dict)
                var_name  = self.__var_name(column_name, column_dict)

                if len(var_name) > max_var_length:
                    max_var_length = len(var_name)

                if table_name == root_name:
                    if len(var_name) > byany_max_var_length:
                        byany_max_var_length = len(var_name)
                else:
                    if len(string.lower(table_name)+'_'+var_name) > byany_max_var_length:
                        byany_max_var_length = len(string.lower(table_name)+'_'+var_name)
                
                # aggregate arg
                if func_name != column_name:
                    var_list.append([var_name, 'None', pytype_str] )
                    if table_name == root_name:
                        byany_var_list.append([var_name, 'None', pytype_str] )
                    else:
                        byany_var_list.append([string.lower(table_name)+'_'+var_name, 'None', pytype_str] )

                    # criteria
                    proof_imports.append( "import proof.Aggregate as Aggregate" )
                
                    crit_list.append( """\
        if %(var_name)s != None:
            if issubclass(%(var_name)s.__class__, Aggregate.Aggregate) and \\
                   %(var_name)s.__class__.__name__ == '%(func_name)sAggregate':
                crit['%(table_name)s.%(column_name)s'] = %(var_name)s.getPK().getValue()
            elif %(var_name)s == 'null':
                crit['%(table_name)s.%(column_name)s'] = None""" % { 'var_name'    : var_name,
                                                                     'func_name'   : func_name,
                                                                     'table_name'  : table_name,
                                                                     'column_name' : column_name } )

                elif column_dict['type'] == 'datetime' or column_dict['type'] == 'date':
                    var_list.append([var_name, 'None', pytype_str] )
                    if table_name == root_name:
                        byany_var_list.append([var_name, 'None', pytype_str] )
                    else:
                        byany_var_list.append([string.lower(table_name)+'_'+var_name, 'None', pytype_str] )
                
                    crit_list.append( """\
        if %(var_name)s != None:
            if %(var_name)s == 'null':
                crit['%(table_name)s.%(column_name)s'] = None
            else:
                crit['%(table_name)s.%(column_name)s'] = %(var_name)s""" % { 'var_name'    : var_name,
                                                                             'table_name'  : table_name,
                                                                             'column_name' : column_name } )
                # like sql
                elif column_dict['type'] in ('char', 'varchar', 'tinyblob', 'tinytext', 'blob', 'text',
                                             'mediumblob', 'mediumtext', 'longblob', 'longtext'):
                    var_list.append([var_name, 'None', pytype_str] )
                    if table_name == root_name:
                        byany_var_list.append([var_name, 'None', pytype_str] )
                    else:
                        byany_var_list.append([string.lower(table_name)+'_'+var_name, 'None', pytype_str] )
                        
                    temp_dict = { 'var_name'    : var_name,
                                  'table_name'  : table_name,
                                  'column_name' : column_name }
                    crit_list.append( """\
        if %(var_name)s != None:""" % temp_dict + """
            if use_like:
                leftsign = rightsign = '%'
                if use_like == 'left':
                    rightsign = ''
                elif use_like == 'right':
                    leftsign = ''""" + """
                crit.add('%(table_name)s.%(column_name)s', leftsign+""" % temp_dict + var_name + """+rightsign, comparison=SQLConstants.LIKE)
            else:
                crit.add('%(table_name)s.%(column_name)s', %(var_name)s)"""  % temp_dict )
                
                # consider as a list
                elif column_dict['type'] in ['enum', 'set']:
                    var_list.append([var_name, 'None', pytype_str] )
                    if table_name == root_name:
                        byany_var_list.append([var_name, 'None', pytype_str] )
                    else:
                        byany_var_list.append([string.lower(table_name)+'_'+var_name, 'None', pytype_str] )
                    
                    crit_list.append( """\
        if %(var_name)s != None:
            if type(%(var_name)s) != type([]):
                %(var_name)s = [%(var_name)s]
            crit.add('%(table_name)s.%(column_name)s', %(var_name)s, comparison=SQLConstants.IN)""" % { 'var_name'    : var_name,
                                                                                                        'table_name'  : table_name,
                                                                                                        'column_name' : column_name } )
            
                elif column_dict['type'] != 'timestamp':
                    var_list.append([var_name, 'None', pytype_str] )
                    if table_name == root_name:
                        byany_var_list.append([var_name, 'None', pytype_str] )
                    else:
                        byany_var_list.append([string.lower(table_name)+'_'+var_name, 'None', pytype_str] )
                    
                    crit_list.append( """\
        if %(var_name)s != None:
            crit['%(table_name)s.%(column_name)s'] = %(var_name)s""" % { 'var_name'    : var_name,
                                                                         'table_name'  : table_name,
                                                                         'column_name' : column_name } )
            # add order_by, limit to var_list
            if len('order_by') > max_var_length:
                max_var_length = len('order_by')

            var_list.append( ['order_by', 'None', """A list of order criteria in the format:
                            [ [ 'Table.ColumnName', 'asc|desc' ], ... ]"""] )
            var_list.append( ['limit', 'None', 'An integer'] )
            var_list.append( ['offset', 'None', 'An integer indicates the start row number'] )
            var_list.append( ['use_like', 'False', """A boolean value indicating whether using like when searching a
                   string column"""] )
        
            crit_vars = ""
            aggr_vars = ""
            aggr_crit_vars = ""
            page_vars = ""
            page_crit_vars = ""

            byany_aggr_crit_vars = ""
            
            params = ""

            identity = ''
            if children_list:
                identity = table_name
            
            relation_crit = ''
            if table_name != root_name:
                lib_imports.append( "import logging" )
                relation_crit = """        
        # add join relationship
        relation = self.getRelationList('%(table_name)s')
        if not relation:
            self.log( "Relationship is not defined between '%(root_name)s' and '%(table_name)s'!",
                      logging.WARNING )
            return crit
        else:
            for left, right in zip(relation[0], relation[1]):
                crit.addJoin(left, right)
        
""" % { 'root_name'   : root_name,
        'table_name'  : table_name }
                
            for var_name, value, pytype_str in var_list:
                crit_vars += "%s%s%s = %s,\n%s" % (" "*len(identity), var_name, " "*(max_var_length-len(var_name)), value, " "*23)
                aggr_vars += "%s%s%s = %s,\n%s" % (" "*len(identity), var_name, " "*(max_var_length-len(var_name)), value, " "*19)
                if aggr_crit_vars:
                    aggr_crit_vars += " "*len(identity)
                aggr_crit_vars += "%s%s = %s,\n%s" % (var_name, " "*(max_var_length-len(var_name)), var_name, " "*35)

                if byany_aggr_crit_vars:
                    if table_name == root_name:
                        byany_aggr_crit_vars += " "*len(identity)
                    else:
                        byany_aggr_crit_vars += " "*(len(identity)*2+1)
                if table_name == root_name or var_name in ['order_by','limit','offset','use_like']:
                    byany_aggr_crit_vars += "%s%s = %s,\n%s" % (var_name, " "*(max_var_length-len(var_name)), var_name, " "*35)
                else:
                    byany_aggr_crit_vars += "%s%s = %s,\n%s" % (var_name, " "*(max_var_length-len(var_name)), string.lower(table_name)+'_'+var_name, " "*35)
                
                page_vars += "%s%s%s = %s,\n%s" % (" "*len(identity), var_name, " "*(max_var_length-len(var_name)), value, " "*29)
                if page_crit_vars:
                    page_crit_vars += " "*len(identity)
                page_crit_vars += "%s%s = %s,\n%s" % (var_name, " "*(max_var_length-len(var_name)), var_name, " "*35)

                params += "@param %s %s.\n%s" % (var_name, pytype_str.replace(' or None', ''), " "*12)

            if crit_vars:
                crit_vars += " "*len(identity)

            if aggr_vars:
                aggr_vars += " "*len(identity)

            if aggr_crit_vars:
                aggr_crit_vars += " "*len(identity)

            if page_vars:
                page_vars += " "*len(identity)

            if page_crit_vars:
                page_crit_vars += " "*len(identity)

            if table_name == root_name:
                byany_aggr_crit_vars += " "*len(identity)
            else:
                byany_aggr_crit_vars += " "*(len(identity)*2+1)

            function_list.append( """\
    def criteriaBy%sAny( self,
                       %s):
        """ % (identity, crit_vars) + '"""' + """ Return a Criteria object based on By%sAny query.
        """ % (identity) + '"""' + """
        
        crit = Criteria.Criteria( self.getProofInstance(),
                                  db_name     = self.getDBName(),
                                  logger      = self.getLogger() )

%s%s

        if order_by and type(order_by) == type([]):
            for row in order_by:
                if len(row) == 2:
                    if string.lower(row[1]) == 'desc':
                        crit.addDescendingOrderByColumn(row[0])
                    else:
                        crit.addAscendingOrderByColumn(row[0])

        if limit and type(limit)==type(1) and limit>0:
            crit.setLimit(limit)

        if offset and type(offset)==type(1) and offset>0:
            crit.setOffset(offset)
        
        return crit""" % (relation_crit, string.join(crit_list, "\n\n")) )

            if identity:
                if table_name == root_name:
                    byany_crit_list.append( """\
        crit = self.criteriaBy%sAny( %s)""" % (identity, byany_aggr_crit_vars) )
                else:
                    byany_crit_list.append( """\
        %(identity_lower)s_crit = self.criteriaBy%(identity)sAny( %(vars)s)

        if len(%(identity_lower)s_crit) > 0:
            crit.addDict(%(identity_lower)s_crit)""" % { 'identity' : identity,
                                                         'identity_lower' : string.lower(identity),
                                                         'vars' : byany_aggr_crit_vars } )

            function_list.append( """\
    def findBy%sAny( self,
                   %s):
        """ % (identity, aggr_vars) + '"""' + """ Search by any possible %s column values. All arguments are optional,
            but at least one column value has to be specified.

            %s
            @return A list of %sAggregate objects based on the criteria specified.
        """ % (identity, params, root_name) + '"""' + """

        # construct criteria
        crit = self.criteriaBy%sAny( %s)"""  % (identity, aggr_crit_vars) + """
        
        if len(crit) > 0 or crit.getLimit() > 0:
            return self.findByCriteria(crit)

        else:
            # no criteria specified.
            self.log( "%s.findBy"""+identity+"""Any: no criteria specified." % (self.__class__.__name__) )
            return []""" )

            params = string.replace(params, 'limit An integer', 'limit An integer, default 10')

            function_list.append( """\
    def findPageSelectBy%sAny( self,
                             %s):
        """ % (identity, page_vars) + '"""' + """ Search by any possible %s column values. All arguments are optional.

            %s
            @return A PageSelect object.
        """ % (identity, params) + '"""' + """
        
        # check limit
        if type(limit) != type(1) or limit < 1:
            limit = 10

        # construct criteria
        crit = self.criteriaBy%sAny( %s)

        # return a PageSelect object
        return self.findPageSelectByCriteria(crit)""" % (identity, page_crit_vars) )

        # end for loop

        # byany
        if children_list:
            byany_var_list.append( ['order_by', 'None', """A list of order criteria in the format:
                            [ [ 'Table.ColumnName', 'asc|desc' ], ... ]"""] )
            byany_var_list.append( ['limit', 'None', 'An integer'] )
            byany_var_list.append( ['offset', 'None', 'An integer indicates the start row number'] )
            byany_var_list.append( ['use_like', 'False', """A boolean value indicating whether using like when searching a
                   string column"""] )

            byany_crit_vars = ""
            byany_aggr_vars = ""
            byany_aggr_crit_vars = ""
            byany_page_vars = ""
            byany_page_crit_vars = ""
            byany_params = ""

            for var_name, value, pytype_str in byany_var_list:
                byany_crit_vars += "%s%s = %s,\n%s" % (var_name, " "*(byany_max_var_length-len(var_name)), value, " "*23)
                byany_aggr_vars += "%s%s = %s,\n%s" % (var_name, " "*(byany_max_var_length-len(var_name)), value, " "*19)
                byany_aggr_crit_vars += "%s%s = %s,\n%s" % (var_name, " "*(byany_max_var_length-len(var_name)), var_name, " "*35)
                byany_page_vars += "%s%s = %s,\n%s" % (var_name, " "*(byany_max_var_length-len(var_name)), value, " "*29)
                byany_page_crit_vars += "%s%s = %s,\n%s" % (var_name, " "*(byany_max_var_length-len(var_name)), var_name, " "*35)

                byany_params += "@param %s %s.\n%s" % (var_name, pytype_str.replace(' or None', ''), " "*12)

            byany_page_params = string.replace(byany_params, 'limit An integer', 'limit An integer, default 10')

            # insert findPageSelectByAny
            function_list.insert(0, """\
    def findPageSelectByAny( self,
                             %s):
        """ % (byany_page_vars) + '"""' + """ Search by any possible column values. All arguments are optional.

            %s
            @return A PageSelect object.
        """ % (byany_page_params) + '"""' + """
        
        # check limit
        if type(limit) != type(1) or limit < 1:
            limit = 10

        # construct criteria
        crit = self.criteriaByAny( %s)

        # return a PageSelect object
        return self.findPageSelectByCriteria(crit)""" % (byany_page_crit_vars) )

            # insert findByAny
            function_list.insert(0, """\
    def findByAny( self,
                   %s):
        """ % (byany_aggr_vars) + '"""' + """ Search by any possible column values. All arguments are optional, but at least
            one column value has to be specified.

            %s
            @return A list of %sAggregate objects based on the criteria specified.
        """ % (byany_params, root_name) + '"""' + """

        # construct criteria
        crit = self.criteriaByAny( %s)"""  % (byany_aggr_crit_vars) + """
        
        if len(crit) > 0 or crit.getLimit() > 0:
            return self.findByCriteria(crit)

        else:
            # no criteria specified.
            self.log( "%s.findByAny: no criteria specified." % (self.__class__.__name__) )
            return []""" )
            
            # insert criteriaByAny
            function_list.insert(0, """\
    def criteriaByAny( self,
                       %s):
        """ % (byany_crit_vars) + '"""' + """ Return a Criteria object based on ByAny query.
        """ + '"""' + """
        
%s

        return crit""" % (string.join(byany_crit_list, "\n\n")) )

        imports = ''
        if len(lib_imports) > 0:
            imports += "%s\n\n" % (string.join(lib_imports, "\n"))

        if len(dpm_imports) > 0:
            imports += "%s\n\n" % (string.join(dpm_imports, "\n"))

        if len(proof_imports) > 0:
            imports += "%s\n\n" % (string.join(proof_imports, "\n"))

        return file_name, REPOSITORY_TEMPLATE % { 'header'        : header,
                                                  'imports'       : imports,
                                                  'table_name'    : root_name,
                                                  'schema_name'   : self.__schema_name,
                                                  'relation_map'  : relation_map,
                                                  'function_list' : string.join(function_list, "\n\n") }
        
    
    def __func_name(self, column_name, column_dict):
        if column_dict['fktable'] != 'none' and \
               column_dict['fktable'] in self.__aggregates.keys():
            return column_dict['fktable']
        else:
            return column_name

    def __var_name(self, column_name, column_dict):

        var = ''

        if column_dict['fktable'] != 'none':
            var = column_dict['fktable']
        else:
            var = column_name

        var = re.sub(r'([a-z]+)([A-Z]+?)', r'\1_\2', var)
        
        var = string.lower(var)
        
        while var in RESTRICTED_VAR_NAMES:
            var = "v_%s"%(var)

        return var

    def __sql2py_type_str(self, column_dict):

        sql_type = string.lower(column_dict['type'])
        notnull  = column_dict['notnull']

        pytype_str = ""

        if column_dict['fktable'] != 'none' and \
               column_dict['fktable'] in self.__aggregates.keys():
            pytype_str = "A(n) %sAggregate object" % (column_dict['fktable'])
        elif sql_type in [ 'tinyint', 'smallint', 'mediumint', 'int', 'integer', 'bigint' ]:
            pytype_str = "An integer"
        elif sql_type in [ 'float', 'double', 'real' ]:
            pytype_str = "A float"
        elif sql_type in [ 'decimal', 'dec', 'numeric', 'fixed' ]:
            pytype_str = "A numeric string"
        elif sql_type in [ 'char', 'varchar', 'tinyblob', 'tinytext', 'blob', 'text',
                           'mediumblob', 'mediumtext', 'longblob', 'longtext' ]:
            pytype_str = "A string"
        elif sql_type in [ 'enum', 'set' ]:
            pytype_str = "A string of %s" % (column_dict['values'])
        elif sql_type in [ 'bit', 'bool', 'boolean' ]:
            pytype_str = "A boolean value"
        elif sql_type in [ 'datetime', 'timestamp' ]:
            pytype_str = "A datetime.datetime object"
        elif sql_type in [ 'date' ]:
            pytype_str = "A datetime.date object"
        elif sql_type in [ 'time' ]:
            pytype_str = "A datetime.timedelta object"
        else:
            pytype_str = "A %s" % (sql_type)

        if notnull == 'false' and sql_type not in [ 'enum', 'set' ]:
            pytype_str += " or %s" % (`column_dict['default']`)
        
        return pytype_str
        
    def __recontruct_tables( self,
                             table_name,
                             column_list,
                             children_list=None ):
        """ Reorganize the tables in an aggregate to a loopable list.
        """
        table_list = [[table_name,column_list,'','','']]
        if children_list:
            for child in children_list:
                table_list.append(child)
        return table_list


def usage(msg=''):

    print """USAGE:
%s options [-c filename]

Generate PROOF Code for database schemas configured in the given 
configuration file.

Options:
    -h, --help   -- print this message
    -c, --cfg    -- specify the configuration filename, default 
                    'resource.cfg'

"""%( sys.argv[0] )
    if msg:
        print >> sys.stderr, msg

    sys.exit(1)
    
if __name__ == '__main__':

    # options:
    # for simplity, we use config file for now
    try:
        opts, args = getopt.getopt(sys.argv[1:], 'hc:', ['help', 'cfg='])
    except getopt.error, msg:
        usage()

    cfg_filename = 'resource.cfg'

    for opt, arg in opts:
        if opt in ('-h', '--help'):
            usage()

        if opt in ('-c', '--cfg'):
            cfg_filename = arg

    config = ConfigParser.ConfigParser()

    try:
        config.readfp(open(cfg_filename))
    except:
        usage(msg=traceBack())

    # required parameters
    proof_path = config.get('INFO', 'proof_path')
    
    # optional
    kwargs = {}
    for opt in ['python_path']:
        if config.has_option('INFO', opt):
            kwargs[opt] = config.get('INFO', opt)

    # schemas
    schemas = []
    sections = config.sections()
    for section in sections:
        if section != 'INFO':
            # schema
            aggregate_dict = {}
            if config.has_option(section, 'aggregates'):
                aggregates = config.get(section, 'aggregates')
                aggregate_list = string.split(aggregates, ",")
                for aggregate in aggregate_list:
                    aggregate_dict[aggregate] = {}
                    if config.has_option(section, aggregate):
                        child_list = string.split(config.get(section, aggregate), "|")
                        for child in child_list:
                            child_spec_list = string.split(child, ",")
                            aggregate_dict[aggregate][child_spec_list[0]] = child_spec_list

            #print "Parsed Aggregates: %s" % (aggregate_dict)

            schemas.append( { 'db_host' : config.get(section, 'db_host'),
                              'db_name' : config.get(section, 'db_name'),
                              'db_user' : config.get(section, 'db_user'),
                              'db_pass' : config.get(section, 'db_pass'),
                              'aggregates' : aggregate_dict,
                              } )

    code_gen = CodeGenerator(proof_path, schemas, **kwargs)

    code_gen.process()
